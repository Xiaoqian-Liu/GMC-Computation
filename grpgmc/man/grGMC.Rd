% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/grGMC.R
\name{grGMC}
\alias{grGMC}
\title{Linear regression with group GMC}
\usage{
grGMC(
  y,
  A,
  theta = 0.9,
  group = 1:ncol(A),
  lambda,
  group.multiplier,
  x0,
  v0,
  Z.method = "theta",
  Z.epsilon = 0.001,
  maxiters = 1000,
  tol = 0.001,
  df.method = "group",
  returnX = FALSE,
  ShowTime = TRUE
)
}
\arguments{
\item{y}{The response variable}

\item{A}{The design matrix without an intercept. grGMC standardizes the data and includes an intercept by default.}

\item{theta}{The convexity-preserving parameter theta in the group GMC penalty}

\item{group}{A vector describing the grouping of the coefficients}

\item{lambda}{The tunning parameter in grGMC, usually a user supplied sequence of decrasing values.}

\item{group.multiplier}{The weight vector for the group GMC penalty}

\item{x0}{Initial value for x, suggest use the last solution when having a sequence of lambda}

\item{v0}{Initial value for v, similar with x0}

\item{Z.method}{Which method to set a matrix parameter Z = lambda B^TB/n}

\item{Z.epsilon}{The epsilon parameter in the new method of geenrating Z}

\item{maxiters}{The max number of iterations for the PDHG algorithm. The solution is computed by the
adaptive PDHG algorithm using all the default values for the parameters in adaptive_pdhg function.}

\item{tol}{The relative decrease in the residuals before the adaptive PDHG algorithm stops}

\item{df.method}{Method to compute degrees of freedom, "group", "active" or "Breheny"}

\item{returnX}{Whether to return the standardized data}

\item{ShowTime}{Whether to show the time cost for computing the solution}
}
\value{
\code{beta} The fitted matrix of coefficients.
The number of rows is equal to the number of coefficients,
and the number of columns is equal to the length of the sequence of lambda.

\code{family} Only "gaussian" is allowed for now.

\code{penalty} We call our penalty as grGMC.

\code{group} Same as above

\code{lambda} The sequence of lambda values in the path.

\code{theta} The theta parameter used in group GMC penalty.

\code{n} Number of observations.

\code{iter} A vector containg the number of iterations
for the PDHG algorithm for each solution

\code{df} A vector containg the degrees of freedom for
 all the points along the regularization path.

\code{loss} A vector containing the residual sum of squares of
 the fitted model at each value of lambda.

\code{bb} The fitted matrix of coefficients for the standardized data.
 This return is used as a warm start when having a sequence of lambda.

\code{obj} The vector of objective values at each solution point

\code{group.multiplier} A named vector containing the multiplicative constant
 applied to each group's penalty.
}
\description{
\code{grGMC} fit regularization paths for linear regression models with the groupe GMC penalty
over a grid of values for the regularization parameter lambda.
}
\examples{
set.seed(1234)
## set the ture signal
x_star=c(0, 3, 9, 0, 0, 15, 0, 4, 5, 0)
p=length(x_star)
##group the variables
group=c(2, 1, 1, 3, 2, 1, 3, 4, 4, 3)
##set sample size
n=15
## generate the covariate matrix
A=matrix(rnorm(n*p, mean = 1, sd=1), nrow = n)
## set the group weights
gp=unique(group)
J=length(gp)
K=rep(0,J)
for (j in 1:J) {
K[j]=sqrt(length(which(group==gp[j])))
}
## response vector
y=as.vector(A\%*\%x_star+rnorm(n, mean=0, sd = 0.5))
lambda=1
## set initial values
x0=v0=double(p)
## fit with grGMC function
fit_GMC <- grGMC(y=y, A=A, theta=0.9, group=group, lambda=lambda, group.multiplier=K, maxiters=1e3)
}
\author{
Xiaoqian Liu
}
